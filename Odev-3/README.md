# Ödev 3 


| Grup Üyeleri    | Katkıları | Github | 
|-----------------|-----------|--------|
| Yasin Ünal      | ? | [<image style="width:30px" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png">](https://github.com/Pilestin) | 
| Osman Büyükşar  | ? | [<image style="width:30px" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png">](https://github.com/OsmanBuyuksar) | 
| Kadir Emre Özer | ? | [<image style="width:30px" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png">](https://github.com/logaritmabir)  | 
| Berkin Aker      | -  |    |   
| Muharrem Sevimli | -  |    |   
| Furkan Kaymak    | -  |    |   
  
  
  # Bilgisayar Ağları

## RPLAlgoritmasının

## FarklıLinkKriterlerineGöreÇalıştırılması

## DersSorumlusu

```
Dr.Öğr.ÜyesiSercanDemirci
```
## Asistan
  
  
  
  
  RPL Nedir RPL IPv6 kullanan bir ağ yönlendirme protokolüdür. İsmi, “ripple” yani dalgalanmadan gelir. RPL veri yapısı olarak DAG veya DODAG yapısını kullanır. Ağın oluşumu kök düğüm tarafından başlatılır. Bu noktadan sonra root bazı mesajlar yayınlayarak ağın oluşturulmasını sağlar. Bu mesajlara DIO (DODAG Information Object ) adı verilir ve mesajı alan cihazlar ağa katılırlar. Sırasıyla yeni bir düğüm şu şekilde ağa katılır :  Ağa katılmamış olan bir düğüm DIS (DODAG Information Solicitation) mesajları yayınlayarak ağı tarar ve kendini duyurmaya çalışır. Ağdaki başka bir düğüme (veya köke) ulaşan bu mesaj , yeni bir DIO mesajı gönderilerek cihazın ağa tanıtılmasına sebep olur. Yeni düğüm gönderilen bu DIO’yu alır ve ağa katılır.  Bu aşamada yeni katılan düğüm ilk aşamada ebeveynini bulmaya çalışır. Bu noktada bağlantı kalitesine bakar ve hesaplama yapar. Ardından bulduğu ebeveyni onaylamak için DAO mesajı gönderir. Ebeveyn DAO mesajını alıp DAO-ACK mesajı ile karşılık gönderir ve bunu alan yeni düğüm bu noktadan sonra kendini ağın bir parçası olarak görür. Senaryo-1 Algoritması ( Çalışma Mantığı ) Senaryo 1 için hop sayısına bakılması gerekiyor, bu da root’a olan uzaklığımız anlamına gelir. Bu bilginin elde edilmesi için düğümün öncelikle ağa katılması gerekir. Bunun için ağa bağlanacak düğüm DIS yayınlar, bu sayede çekim alanındaki düğümlerin zamanlayıcılarını yeniden başlatarak DIO alma olasılığını arttırır. DIO alındıktan sonra komşu düğüm ile DIO paketleri alıp- verilerek link-probing yani linkin kalitesi ölçülür. Ölçülen değerlere göre düğüm ağa bağlanırken hangi düğümü parent seçeceğini belirler. Bir parent seçildiğinde, o - 2 -
- 3 - parent’ın rank değerinin bir fazlası, bağlanan düğümün rankı olacak şekilde tanımlanır. Bu sayede ağa katılan her düğümde rank değişkeni root’a olan uzaklığı tutar. Senaryo-1 için DIO objesi alındığında rank’ın minimum olduğu düğüm seçilir. Bu sayede her düğüm ağa bağlanırken yol olarak root’a en kısa hop sayısı ile giden yolu seçer. Objective Function dosyası değiştirilenler 1.senaryonun yapılması için sadece maliyet metriğinin değiştirilmesi yeterli, dolayısıyla rpl-of-minhop.c dosyasında mrhof.c dosyasından farklı olarak sadece nbr_link_metric() fonksiyonu ve nbr_path_cost() fonksiyonu değiştirilmiştir. Diğer fonksiyonların varsayılan halleri senaryoyu sağladığı için onlarda herhangi bir değişiklik yapılmamıştır. nbr_link_metric() fonksiyonunda dönüş değeri; return nbr != NULL ? nbr->rank : 0xffff; olarak değiştirilmiştir bu sayede link metriğinde önemli olan tek faktör rank yani kökten olan uzaklık olacak hale getirilmiştir. nbr_path_cost() fonksiyonunda ise dönüş değeri sadece nbr_link_metric() fonksiyonunun dönüş değeri olacak şekilde değiştirilmiştir. Bu sayede herhangi bir fonksiyon yolun maliyetini hesapladığında sadece düğümün kökten olan uzaklığını baz alacaktır. Yapılan değişikliklerden sonra oluşturulan objective function dosyasının işletim sistemine dahil edilmesi için contiki-ng/os/net/routing/rpl-lite/rpl-conf.h dosyasında 97.satıra #define RPL_SUPPORTED_OFS {&rpl-of- minhop} yazılmıştır. Senaryo 1 için fonksiyonlar Bu senaryo için kullanılan fonksiyonlar aşağıdaki gibidir.  reset(dag) reset metodu, belirli bir DAG için fonksiyon durumunu sıfırlar. Metot DAG üzerinde global bir onarım işlemi sırasında çağrılmlaktadır. Metot içeriğinde ise sadece bir log info mesajı bulunmaktadır. Yani metodun amacı, değerleri sıfırlamak veya başlangıç durumuna döndürmektir(DAG için).  nbr_link_metric(n)
- 4 - Belirtilen komşu için bağlantı metrik değerini döndürür. Parametre olarak nbr_t türünde nbr(komşu) nesnesi alır. Eğer bu fonksiyon geriye stats nesnesini döndürür ise(komşu ile bağlantı varsa), stats’ın etx değerini return eder. Eğer stats nesnesi döndürülmez ise(komşu bağlantısı yoksa) 0xffff döndürür.  nbr_has_usable_link(n) Belirtilen komşu için bağlantı metrik değerinin kontrolü yapılır ve kullanılabilir(usable) olup olmadığı return edilir. Bu fonksiyon, rpl_nbr_t tipinde bir nbr yani komşu nesnesi alır. nbr_link_metric’ten dönen komşu metrik değerinin MAX_LINK_METRIC değerinden küçük veya eşit olmadığının kontrolü yapılır. Eğer MAX_LINK_METRIC’TEN küçük veya eşit ise, fonksiyon 1 return eder, değilse 0 return eder.  nbr_is_acceptable_parent(n) Bu metot, komşunun kullanılabilir bir sıralama/bağlantısı(link) olup olmadığının kontrolünü gerçekleştirir. Metot parametre olarak rpl_nbr_t türünde bir nbr paremetresi alır. Metot içerisinde öncelikle yol cost’u yani maliyeti hesaplanır. Devamında komşunun kullanılabilir bir link(bağlantısı)’e sahip olup olmadığı ve yol maliyetinin MAX_PATH_COST’tan küçük veya eşit olup olmadığı kontrol edilir.  nbr_path_cost(n) Bu metot, komşunun yol maliyetini döndürmektedir. Metot içerisinde, komşu NULL ise 0xffff return edilir. Devamındaki if koşulunda RPL_WITH_MC kontrol edilir fakat senaryo 1 için bu değer 0 olduğundan bu if bloğuna girmez ve else çalışır ve komşunun rank’ı kullanılır. Bu rank ile 0xffff karşılaştırılır ve minimum olan return edilir.  rank_via_nbr(n) Bu metot, spesifik olarak bir komşu seçildiğinde kendi sıralamamızı return eder.  best_parent(n1, n2) Best_parent metotu, iki komşuyu karşılaştırır ve OF(Objective Function)’ye göre en iyi olanı return eder.  update_metric_container() Mevcut OF(Objective Function) ile DAG metrik kapsayıcısı güncellenir. Metot içerisinde ilk olarak RPL_WITH_MC kontrolü yapılır. 1.senaryo için RPL_WITH_MC 0 olduğundan bu if bloğu çalışır ve yalnızca curr_instance.mc.type = RPL_DAG_MC_NONE; ataması gerçekleştirilir. Senaryo-2 Algoritması ( Çalışma Mantığı ) Burada yeni bir of dosyası oluşturulmadı. mrhof.c içerisinde düzenlemeye yapmaya çalışıldı. * mrhof.c içerisinde rpl işlevlerinin ne anlama geldiği, rpl-types.h kütüphanesi içerisinde 150.satırda başlayan yorum satırlarından öğrenildi.  nbr_link_metric() işlevi içerisinde kullanılan stats→etx yerine stats→rssi denemesi yapıldı.  Daha sonra nbr_path_cost() işlevinin içerisinde switch(curr_instance.mc.type) seçimi içerisine case RPL_DAG_MC_LQL: denenmeye çalışıldı fakat metric_object değişkeni
enerji ve etx tabanlı olduğu için burada bağlantı kalitesine uygun bir “base” ataması yapılamadı.  mrhof.c ‘nin kendisinden tanımlı within_hysteresis() işlevi gecikmesine göre bir best_parent() içerisinde seçim yaptığı için within_hysteresis() işlevi olmadan,bağlantı sinyaline dayalı bir ebeveyn tayini yapılmaya çalışıldı bu durum da hüsran. Bu kısımlar gerçeklenemese de video sonunda anlatıldı.
  
